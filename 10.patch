diff -up boost_1_73_0/boost/bimap/container_adaptor/support/iterator_facade_converters.hpp.12~ boost_1_73_0/boost/bimap/container_adaptor/support/iterator_facade_converters.hpp
--- boost_1_73_0/boost/bimap/container_adaptor/support/iterator_facade_converters.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/container_adaptor/support/iterator_facade_converters.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -28,7 +28,7 @@ namespace support {
 
 /// \brief Converter for Boost.Iterators based iterators.
 /**
-Container adaptor is dessigned to play well with Boost.Iterators. This
+Container adaptor is designed to play well with Boost.Iterators. This
 converter can be used if this library is used to adapt the iterators.
                                                                             **/
 template
diff -up boost_1_73_0/boost/bimap/detail/bimap_core.hpp.12~ boost_1_73_0/boost/bimap/detail/bimap_core.hpp
--- boost_1_73_0/boost/bimap/detail/bimap_core.hpp.12~	2020-04-29 14:31:09.748214394 +0200
+++ boost_1_73_0/boost/bimap/detail/bimap_core.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -266,7 +266,7 @@ class bimap_core
 
     // If it is based either on the left or on the right, then only the side
     // indices are needed. But the set type of the relation can be completely
-    // diferent from the one used for the sides in wich case we have to add yet
+    // different from the one used for the sides in which case we have to add yet
     // another index to the core.
 
     // TODO
@@ -309,7 +309,7 @@ class bimap_core
                         relation_set_type_of;
 
     // Logic tags
-    // This is a necesary extra level of indirection to allow unconstrained
+    // This is a necessary extra level of indirection to allow unconstrained
     // sets to be plug in the design. The bimap constructors use this logic
     // tags.
 
@@ -452,7 +452,7 @@ class bimap_core
     typedef bimap_core bimap_core_;
 };
 
-// Two auxiliar metafunctions to compute the map view types
+// Two auxiliary metafunctions to compute the map view types
 // The map view type can not be computed inside the bimap core because a 
 // they need the bimap core to be parsed first.
 
diff -up boost_1_73_0/boost/bimap/detail/concept_tags.hpp.12~ boost_1_73_0/boost/bimap/detail/concept_tags.hpp
--- boost_1_73_0/boost/bimap/detail/concept_tags.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/detail/concept_tags.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -34,7 +34,7 @@ metafunctions. For example now is easy t
 
 struct set_type_of_tag          {};
 
-/// \brief Tag of {SetType}_of_relation defition classes
+/// \brief Tag of {SetType}_of_relation definition classes
 
 struct set_type_of_relation_tag {};
 
@@ -68,7 +68,7 @@ See also left_based.
 struct left_based : ::boost::bimaps::detail::side_based_tag
 {
     // I run into troubles if I do not define bind for side based tags.
-    // Maybe a more coherent way of binding the relation can be developped.
+    // Maybe a more coherent way of binding the relation can be developed.
     template< class Relation > struct bind_to { typedef void type; };
 
     typedef mpl::bool_<true>  left_mutable_key;
@@ -78,7 +78,7 @@ struct left_based : ::boost::bimaps::det
 struct right_based : ::boost::bimaps::detail::side_based_tag
 {
     // I run into troubles if I do not define bind for side based tags.
-    // Maybe a more coherent way of binding the relation can be developped.
+    // Maybe a more coherent way of binding the relation can be developed.
     template< class Relation > struct bind_to { typedef void type; };
 
     typedef mpl::bool_<true>  left_mutable_key;
diff -up boost_1_73_0/boost/bimap/relation/member_at.hpp.12~ boost_1_73_0/boost/bimap/relation/member_at.hpp
--- boost_1_73_0/boost/bimap/relation/member_at.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/member_at.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -25,7 +25,7 @@ namespace relation {
 /// \brief member_at::side idiom to access relation values and types using metaprogramming. 
 /**
 
-This tags are used to specify which member you want to acces when using a metafunction over
+This tags are used to specify which member you want to access when using a metafunction over
 a symmetrical type. The idea is to be able to write code like:
 
 \code
@@ -44,7 +44,7 @@ namespace member_at {
 
     /// \brief Member at left tag
     /**
-    See also member_at, rigth.
+    See also member_at, right.
                                             **/
 
     struct left  {};
diff -up boost_1_73_0/boost/bimap/relation/structured_pair.hpp.12~ boost_1_73_0/boost/bimap/relation/structured_pair.hpp
--- boost_1_73_0/boost/bimap/relation/structured_pair.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/structured_pair.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -254,7 +254,7 @@ class mutant_relation;
 /// \brief A std::pair signature compatible class that allows you to control
 ///        the internal structure of the data.
 /**
-This class allows you to specify the order in wich the two data types will be
+This class allows you to specify the order in which the two data types will be
 in the layout of the class.
                                                                                **/
 
diff -up boost_1_73_0/boost/bimap/relation/support/get.hpp.12~ boost_1_73_0/boost/bimap/relation/support/get.hpp
--- boost_1_73_0/boost/bimap/relation/support/get.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/support/get.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -60,13 +60,13 @@ namespace relation {
 namespace support {
 
 // Since it is very error-prone to directly write the hole bunch
-// of relation accesor. They are buil from litle macro blocks that
+// of relation accesor. They are built from little macro blocks that
 // are both more readable, leading to self docummenting code and a
-// lot more easier to understand and mantain.
+// lot more easier to understand and maintain.
 // It is very important to note that the three building blocks have
 // to laid in the same namespace in order to work. There is also
 // important to keep them in order.
-// The forward declaration are not necesary but they help a lot to
+// The forward declaration are not necessary but they help a lot to
 // the reader, as they undercover what is the signature of the
 // result code.
 // In the end, it is not quicker to do it in this way because you
diff -up boost_1_73_0/boost/bimap/relation/support/is_tag_of_member_at.hpp.12~ boost_1_73_0/boost/bimap/relation/support/is_tag_of_member_at.hpp
--- boost_1_73_0/boost/bimap/relation/support/is_tag_of_member_at.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/support/is_tag_of_member_at.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -27,7 +27,7 @@
 
 /** \struct boost::bimaps::relation::support::is_tag_of_member_at_left
 
-\brief Metafunction to test if a user tag is refering to the left member.
+\brief Metafunction to test if a user tag is referring to the left member.
 
 \code
 
@@ -53,7 +53,7 @@ See also member_with_tag, member_at, is_
 
 /** \struct boost::bimaps::relation::support::is_tag_of_member_at_right
 
-\brief Metafunction to test if a user tag is refering to the left member.
+\brief Metafunction to test if a user tag is referring to the left member.
 
 \code
 
diff -up boost_1_73_0/boost/bimap/relation/support/pair_by.hpp.12~ boost_1_73_0/boost/bimap/relation/support/pair_by.hpp
--- boost_1_73_0/boost/bimap/relation/support/pair_by.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/support/pair_by.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -54,13 +54,13 @@ namespace support {
 
 
 // Since it is very error-prone to directly write the hole bunch
-// of relation accesor. They are buil from litle macro blocks that
+// of relation accesor. They are built from little macro blocks that
 // are both more readable, leading to self docummenting code and a
-// lot more easier to understand and mantain.
+// lot more easier to understand and maintain.
 // It is very important to note that the three building blocks have
 // to laid in the same namespace in order to work. There is also
 // important to keep them in order.
-// The forward declaration are not necesary but they help a lot to
+// The forward declaration are not necessary but they help a lot to
 // the reader, as they undercover what is the signature of the
 // result code.
 // In the end, it is not quicker to do it in this way because you
diff -up boost_1_73_0/boost/bimap/relation/symmetrical_base.hpp.12~ boost_1_73_0/boost/bimap/relation/symmetrical_base.hpp
--- boost_1_73_0/boost/bimap/relation/symmetrical_base.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/relation/symmetrical_base.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -32,7 +32,7 @@ namespace boost {
 namespace bimaps {
 namespace relation {
 
-/// \brief Base of symetrical tagged types.
+/// \brief Base of symmetrical tagged types.
 /**
 
                                                            **/
diff -up boost_1_73_0/boost/bimap/support/map_by.hpp.12~ boost_1_73_0/boost/bimap/support/map_by.hpp
--- boost_1_73_0/boost/bimap/support/map_by.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/support/map_by.hpp	2020-04-29 14:31:09.750214421 +0200
@@ -68,13 +68,13 @@ namespace bimaps {
 namespace support {
 
 // Since it is very error-prone to directly write the hole bunch
-// of relation accesor. They are buil from litle macro blocks that
+// of relation accesor. They are built from little macro blocks that
 // are both more readable, leading to self docummenting code and a
-// lot more easier to understand and mantain.
+// lot more easier to understand and maintain.
 // It is very important to note that the three building blocks have
 // to laid in the same namespace in order to work. There is also
 // important to keep them in order.
-// The forward declaration are not necesary but they help a lot to
+// The forward declaration are not necessary but they help a lot to
 // the reader, as they undercover what is the signature of the
 // result code.
 // In the end, it is not quicker to do it in this way because you
diff -up boost_1_73_0/boost/bimap/tags/support/apply_to_value_type.hpp.12~ boost_1_73_0/boost/bimap/tags/support/apply_to_value_type.hpp
--- boost_1_73_0/boost/bimap/tags/support/apply_to_value_type.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/tags/support/apply_to_value_type.hpp	2020-04-29 14:31:09.751214434 +0200
@@ -38,7 +38,7 @@ struct apply_to_value_type
 \endcode
 
 This higher order metafunctions is very useful, and it can be used with lambda
-expresions.
+expressions.
 
 See also tagged.
                                                                                 **/
diff -up boost_1_73_0/boost/bimap/tags/support/tag_of.hpp.12~ boost_1_73_0/boost/bimap/tags/support/tag_of.hpp
--- boost_1_73_0/boost/bimap/tags/support/tag_of.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/tags/support/tag_of.hpp	2020-04-29 14:31:09.751214434 +0200
@@ -7,7 +7,7 @@
 // http://www.boost.org/LICENSE_1_0.txt)
 
 /// \file tags/support/tag_of.hpp
-/// \brief Safe way to acces the tag of a type
+/// \brief Safe way to access the tag of a type
 
 #ifndef BOOST_BIMAP_TAGS_SUPPORT_TAG_OF_HPP
 #define BOOST_BIMAP_TAGS_SUPPORT_TAG_OF_HPP
diff -up boost_1_73_0/boost/bimap/tags/support/value_type_of.hpp.12~ boost_1_73_0/boost/bimap/tags/support/value_type_of.hpp
--- boost_1_73_0/boost/bimap/tags/support/value_type_of.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/tags/support/value_type_of.hpp	2020-04-29 14:31:09.751214434 +0200
@@ -32,7 +32,7 @@ struct value_type_of
 \endcode
 
 If the type is tagged this metafunction returns Type::value_type, and if it is not
-tagged it return the same type. This allows to work consistenly with tagged and
+tagged it return the same type. This allows to work consistently with tagged and
 untagged types.
 
 See also tagged, tag_of.
diff -up boost_1_73_0/boost/bimap/tags/tagged.hpp.12~ boost_1_73_0/boost/bimap/tags/tagged.hpp
--- boost_1_73_0/boost/bimap/tags/tagged.hpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/boost/bimap/tags/tagged.hpp	2020-04-29 14:31:09.751214434 +0200
@@ -92,7 +92,7 @@ struct tagged
 \brief Metafunctions to work with tagged types.
 
 This metafunctions aims to make easier the manage of tagged types. They are all mpl
-compatible metafunctions and can be used with lambda expresions.
+compatible metafunctions and can be used with lambda expressions.
 The metafunction value_type_of and tag_of get the data in a tagged type in a secure
 and consistent way.
 default_tagged and overwrite_tagged allows to work with the tag of a tagged type,
diff -up boost_1_73_0/libs/bimap/doc/bimap_and_boost.qbk.12~ boost_1_73_0/libs/bimap/doc/bimap_and_boost.qbk
--- boost_1_73_0/libs/bimap/doc/bimap_and_boost.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/bimap_and_boost.qbk	2020-04-29 14:31:09.749214408 +0200
@@ -328,7 +328,7 @@ The following code snippet
 
 [code_bimap_and_boost_typeof_not_using_auto]
 
-can be rewrited as
+can be rewritten as
 
 [code_bimap_and_boost_typeof_using_auto]
 
diff -up boost_1_73_0/libs/bimap/doc/compiler_specifics.qbk.12~ boost_1_73_0/libs/bimap/doc/compiler_specifics.qbk
--- boost_1_73_0/libs/bimap/doc/compiler_specifics.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/compiler_specifics.qbk	2020-04-29 14:31:09.749214408 +0200
@@ -52,7 +52,7 @@ can be cause buffer overruns or other po
 See http://msdn.microsoft.com/msdnmag/issues/05/05/SafeCandC/default.aspx
 But the wording of the warning is misleading and unsettling, there are no
 portable alternative functions, and VC++ 8.0's own libraries use the
-functions in question. In order to turn off the warnings add the followings
+functions in question. In order to turn off the warnings add the following
 defines at the begging of your .cpp files:
 
     #define _CRT_SECURE_NO_DEPRECATE
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/bimap_and_boost/boost_libraries_that_work_well_with_boost_bimap.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/bimap_and_boost/boost_libraries_that_work_well_with_boost_bimap.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/bimap_and_boost/boost_libraries_that_work_well_with_boost_bimap.html.12~	2020-04-22 15:41:02.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/bimap_and_boost/boost_libraries_that_work_well_with_boost_bimap.html	2020-04-29 14:31:09.749214408 +0200
@@ -352,7 +352,7 @@
 <td width="5%" valign="top" align="left"><p><a name="boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_serialization.c3"></a><a href="#boost_bimap.bimap_and_boost.boost_libraries_that_work_well_with_boost_bimap.boost_serialization.c2"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
 <td valign="top" align="left"><p>
               We can only serialize iterators if the bimap was serialized first.
-              Note that the const cast is not requiered here because we create our
+              Note that the const cast is not required here because we create our
               iterators as const.
             </p></td>
 </tr>
@@ -768,7 +768,7 @@
 <p>
         </p>
 <p>
-          can be rewrited as
+          can be rewritten as
         </p>
 <p>
 </p>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/compiler_specifics.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/compiler_specifics.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/compiler_specifics.html.12~	2020-04-22 15:41:04.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/compiler_specifics.html	2020-04-29 14:31:09.749214408 +0200
@@ -345,7 +345,7 @@
       See http://msdn.microsoft.com/msdnmag/issues/05/05/SafeCandC/default.aspx But
       the wording of the warning is misleading and unsettling, there are no portable
       alternative functions, and VC++ 8.0's own libraries use the functions in question.
-      In order to turn off the warnings add the followings defines at the begging
+      In order to turn off the warnings add the following defines at the begging
       of your .cpp files:
     </p>
 <pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">_CRT_SECURE_NO_DEPRECATE</span>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/examples/multiindex_to_bimap_path___hashed_indices.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/examples/multiindex_to_bimap_path___hashed_indices.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/examples/multiindex_to_bimap_path___hashed_indices.html.12~	2020-04-22 15:41:05.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/examples/multiindex_to_bimap_path___hashed_indices.html	2020-04-29 14:31:09.749214408 +0200
@@ -63,7 +63,7 @@
 <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multi_index</span><span class="special">;</span>
 <span class="keyword">namespace</span> <span class="identifier">bl</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lambda</span><span class="special">;</span>
 
-<span class="comment">// word_counter keeps the ocurrences of words inserted. A hashed</span>
+<span class="comment">// word_counter keeps the occurrences of words inserted. A hashed</span>
 <span class="comment">// index allows for fast checking of preexisting entries.</span>
 
 <span class="keyword">struct</span> <span class="identifier">word_counter_entry</span>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/rationale.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/rationale.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/rationale.html.12~	2020-04-22 15:41:05.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/rationale.html	2020-04-29 14:31:09.749214408 +0200
@@ -277,7 +277,7 @@
         you can build other container that behaves exactly as a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> using
         <code class="computeroutput"><span class="identifier">set_adaptor</span></code> and <code class="literal">iterator_adaptor</code>.
         The combined use of this two tools is very powerful. A <code class="literal">container_adaptor</code>
-        can take classes that do not fulfil all the requirements of the adapted container.
+        can take classes that do not fulfill all the requirements of the adapted container.
         The new container must define these missing functions.
       </p>
 </div>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/set_of_reference.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/set_of_reference.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/set_of_reference.html.12~	2020-04-22 15:41:03.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/set_of_reference.html	2020-04-29 14:31:09.749214408 +0200
@@ -1100,7 +1100,7 @@
 <p>
             The symmetry of bimap imposes some constraints on <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code> and the non constant version of at()
             that are not found in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">maps</span></code>.
-            Tey are only provided if the other collection type is mutable (<code class="computeroutput"><span class="identifier">list_of</span></code>, <code class="computeroutput"><span class="identifier">vector_of</span></code>
+            They are only provided if the other collection type is mutable (<code class="computeroutput"><span class="identifier">list_of</span></code>, <code class="computeroutput"><span class="identifier">vector_of</span></code>
             and <code class="computeroutput"><span class="identifier">unconstrained_set_of</span></code>).
           </p>
 <a name="reference_set_of_operator_bracket_key"></a><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">CompatibleKey</span> <span class="special">&gt;</span>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/unordered_set_of_reference.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/unordered_set_of_reference.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/unordered_set_of_reference.html.12~	2020-04-22 15:41:04.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/reference/unordered_set_of_reference.html	2020-04-29 14:31:09.750214421 +0200
@@ -1013,7 +1013,7 @@
 <p>
             The symmetry of bimap imposes some constraints on <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code> and the non constant version of at()
             that are not found in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">maps</span></code>.
-            Tey are only provided if the other collection type is mutable (<code class="computeroutput"><span class="identifier">list_of</span></code>, <code class="computeroutput"><span class="identifier">vector_of</span></code>
+            They are only provided if the other collection type is mutable (<code class="computeroutput"><span class="identifier">list_of</span></code>, <code class="computeroutput"><span class="identifier">vector_of</span></code>
             and <code class="computeroutput"><span class="identifier">unconstrained_set_of</span></code>).
           </p>
 <a name="reference_unordered_set_of_operator_bracket_key"></a><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">CompatibleKey</span> <span class="special">&gt;</span>
diff -up boost_1_73_0/libs/bimap/doc/html/boost_bimap/the_tutorial/bimaps_with_user_defined_names.html.12~ boost_1_73_0/libs/bimap/doc/html/boost_bimap/the_tutorial/bimaps_with_user_defined_names.html
--- boost_1_73_0/libs/bimap/doc/html/boost_bimap/the_tutorial/bimaps_with_user_defined_names.html.12~	2020-04-29 14:31:09.750214421 +0200
+++ boost_1_73_0/libs/bimap/doc/html/boost_bimap/the_tutorial/bimaps_with_user_defined_names.html	2020-04-29 14:34:20.490735801 +0200
@@ -171,8 +171,8 @@
 <span class="identifier">bm_type</span><span class="special">::</span><span class="identifier">right_iterator</span> <span class="identifier">right_iter</span> <span class="special">=</span> <span class="identifier">bm</span><span class="special">.</span><span class="identifier">right</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
 </pre>
 <div class="table">
-<a name="boost_bimap.the_tutorial.bimaps_with_user_defined_names.t0"></a><p class="title"><b>Table 1.3. Equivalence of expresions using user defined names</b></p>
-<div class="table-contents"><table class="table" summary="Equivalence of expresions using user defined names">
+<a name="boost_bimap.the_tutorial.bimaps_with_user_defined_names.t0"></a><p class="title"><b>Table 1.3. Equivalence of expressions using user defined names</b></p>
+<div class="table-contents"><table class="table" summary="Equivalence of expressions using user defined names">
 <colgroup>
 <col>
 <col>
diff -up boost_1_73_0/libs/bimap/doc/rationale.qbk.12~ boost_1_73_0/libs/bimap/doc/rationale.qbk
--- boost_1_73_0/libs/bimap/doc/rationale.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/rationale.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -206,7 +206,7 @@ iterators instead of the originals. For
 `std::set<int*>`, you can build other container that behaves exactly as a
 `std::set<int>` using `set_adaptor` and [^iterator_adaptor]. The combined use
 of this two tools is very powerful. A [^container_adaptor] can take classes
-that do not fulfil all the requirements of the adapted container. The
+that do not fulfill all the requirements of the adapted container. The
 new container must define these missing functions.
 
 [endsect]
diff -up boost_1_73_0/libs/bimap/doc/reference/list_of.qbk.12~ boost_1_73_0/libs/bimap/doc/reference/list_of.qbk
--- boost_1_73_0/libs/bimap/doc/reference/list_of.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/reference/list_of.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -528,7 +528,7 @@ for ['Set View]. `position` is a valid d
 for ['Set View] where `e` is the element pointed to by `position` and
 rearranges `*position` into all the views of the `bimap`.
 Rearrangement on `list_of` views does not change the position of the element
-with respect to the view; rearrangement on other views may or might not suceed.
+with respect to the view; rearrangement on other views may or might not succeed.
 If the rearrangement fails, the element is erased.
 * [*Postconditions:] Validity of `position` is preserved if the operation succeeds.
 * [*Returns: ] `true` if the operation succeeded, `false` otherwise.
diff -up boost_1_73_0/libs/bimap/doc/reference/set_of.qbk.12~ boost_1_73_0/libs/bimap/doc/reference/set_of.qbk
--- boost_1_73_0/libs/bimap/doc/reference/set_of.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/reference/set_of.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -818,7 +818,7 @@ throws `std::out_of_range` if such key d
 
 The symmetry of bimap imposes some constraints on `operator[]` and the 
 non constant version of at() that are not found in `std::maps`.
-Tey are only provided if the other collection type is mutable
+They are only provided if the other collection type is mutable
 (`list_of`, `vector_of` and `unconstrained_set_of`).
 
 [#reference_set_of_operator_bracket_key]
diff -up boost_1_73_0/libs/bimap/doc/reference/unordered_set_of.qbk.12~ boost_1_73_0/libs/bimap/doc/reference/unordered_set_of.qbk
--- boost_1_73_0/libs/bimap/doc/reference/unordered_set_of.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/reference/unordered_set_of.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -695,7 +695,7 @@ throws `std::out_of_range` if such key d
 
 The symmetry of bimap imposes some constraints on `operator[]` and the 
 non constant version of at() that are not found in `std::maps`.
-Tey are only provided if the other collection type is mutable
+They are only provided if the other collection type is mutable
 (`list_of`, `vector_of` and `unconstrained_set_of`).
 
 
diff -up boost_1_73_0/libs/bimap/doc/reference/vector_of.qbk.12~ boost_1_73_0/libs/bimap/doc/reference/vector_of.qbk
--- boost_1_73_0/libs/bimap/doc/reference/vector_of.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/reference/vector_of.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -574,7 +574,7 @@ for ['Set View] where e is the element p
 rearranges `*position` into all the views of the `bimap`.
 Rearrangement on `vector_of` views does not change the position of the
 element with respect to the view; rearrangement on other views may or
-might not suceed. If the rearrangement fails, the element is erased.
+might not succeed. If the rearrangement fails, the element is erased.
 * [*Postconditions:] Validity of `position` is preserved if the operation succeeds.
 * [*Returns: ] `true` if the operation succeeded, `false` otherwise.
 * [link vector_of_complexity_signature [*Complexity:]] O(M(n)).
diff -up boost_1_73_0/libs/bimap/doc/tutorial.qbk.12~ boost_1_73_0/libs/bimap/doc/tutorial.qbk
--- boost_1_73_0/libs/bimap/doc/tutorial.qbk.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/doc/tutorial.qbk	2020-04-29 14:31:09.750214421 +0200
@@ -811,7 +811,7 @@ the untagged version structures.
 
 
 
-[table Equivalence of expresions using user defined names
+[table Equivalence of expressions using user defined names
 [[Untagged version]               [Tagged version]                     ]
 [[`bm.left`]                      [`bm.by<Left>()`]                    ]
 [[`bm.right`]                     [`bm.by<Right>()`]                   ]
diff -up boost_1_73_0/libs/bimap/example/bimap_and_boost/serialization.cpp.12~ boost_1_73_0/libs/bimap/example/bimap_and_boost/serialization.cpp
--- boost_1_73_0/libs/bimap/example/bimap_and_boost/serialization.cpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/example/bimap_and_boost/serialization.cpp	2020-04-29 14:31:09.750214421 +0200
@@ -52,7 +52,7 @@ int main()
             rationale behind this decision >*/
 
         /*<< We can only serialize iterators if the bimap was serialized first.
-             Note that the const cast is not requiered here because we create
+             Note that the const cast is not required here because we create
              our iterators as const. >>*/
         const bm_type::left_iterator left_iter = bm.left.find("two");
         oa << left_iter;
diff -up boost_1_73_0/libs/bimap/example/mi_to_b_path/mi_hashed_indices.cpp.12~ boost_1_73_0/libs/bimap/example/mi_to_b_path/mi_hashed_indices.cpp
--- boost_1_73_0/libs/bimap/example/mi_to_b_path/mi_hashed_indices.cpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/example/mi_to_b_path/mi_hashed_indices.cpp	2020-04-29 14:31:09.750214421 +0200
@@ -29,7 +29,7 @@ Boost.MultiIndex
 using namespace boost::multi_index;
 namespace bl = boost::lambda;
 
-// word_counter keeps the ocurrences of words inserted. A hashed
+// word_counter keeps the occurrences of words inserted. A hashed
 // index allows for fast checking of preexisting entries.
 
 struct word_counter_entry
diff -up boost_1_73_0/libs/bimap/example/step_by_step.cpp.12~ boost_1_73_0/libs/bimap/example/step_by_step.cpp
--- boost_1_73_0/libs/bimap/example/step_by_step.cpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/example/step_by_step.cpp	2020-04-29 14:31:09.750214421 +0200
@@ -23,7 +23,7 @@
 #include <iostream>
 #include <cassert>
 
-// A convinience header is avaiable in the boost directory:
+// A convenience header is available in the boost directory:
 #include <boost/bimap.hpp>
 
 int main()
diff -up boost_1_73_0/libs/bimap/test/test_structured_pair.cpp.12~ boost_1_73_0/libs/bimap/test/test_structured_pair.cpp
--- boost_1_73_0/libs/bimap/test/test_structured_pair.cpp.12~	2020-04-22 15:34:51.000000000 +0200
+++ boost_1_73_0/libs/bimap/test/test_structured_pair.cpp	2020-04-29 14:31:09.751214434 +0200
@@ -70,7 +70,7 @@ void test_basic()
 
     using namespace boost::bimaps::relation;
 
-    // Instanciate two pairs and test the storage alignmentDataData
+    // Instantiate two pairs and test the storage alignmentDataData
 
     typedef structured_pair< short, double, normal_layout > pair_type;
     typedef structured_pair< double, short, mirror_layout > mirror_type;
