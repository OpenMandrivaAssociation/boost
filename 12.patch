From 7daa6c1b158a1dd3699c3e6b06008b2ca984dfb2 Mon Sep 17 00:00:00 2001
From: CromwellEnage <32967088+CromwellEnage@users.noreply.github.com>
Date: Sun, 30 Sep 2018 02:53:54 -0400
Subject: [PATCH] Update unordered_associative_container_adaptor

The unordered_associative_container_adaptor base class now implements member functions hash_function(), key_eq(), and reserve().
---
 ...nordered_associative_container_adaptor.hpp | 15 +++++++++
 test/test_bimap.hpp                           | 12 +++++++
 test/test_bimap_unordered.cpp                 | 31 +++++++++++++++++++
 3 files changed, 58 insertions(+)

diff --git a/boost/bimap/container_adaptor/unordered_associative_container_adaptor.hpp b/boost/bimap/container_adaptor/unordered_associative_container_adaptor.hpp
index 7ecffcf..b945f1c 100755
--- a/boost/bimap/container_adaptor/unordered_associative_container_adaptor.hpp
+++ b/boost/bimap/container_adaptor/unordered_associative_container_adaptor.hpp
@@ -184,6 +184,16 @@ class unordered_associative_container_adaptor :
 
     // bucket interface:
 
+    hasher hash_function() const
+    {
+        return this->base().hash_function();
+    }
+
+    key_equal key_eq() const
+    {
+        return this->base().key_eq();
+    }
+
     BOOST_DEDUCED_TYPENAME base_::size_type bucket_count() const
     {
         return this->base().bucket_count();
@@ -260,6 +270,11 @@ class unordered_associative_container_adaptor :
         return this->base().rehash(n);
     }
 
+    void reserve(BOOST_DEDUCED_TYPENAME base_::size_type count)
+    {
+        return this->base().reserve(count);
+    }
+
     // We have redefined end and begin so we have to manually route the old ones
 
     BOOST_DEDUCED_TYPENAME base_::iterator begin()
diff --git a/libs/bimap/test/test_bimap.hpp b/libs/bimap/test/test_bimap.hpp
index 973fb6f..3bc09ab 100644
--- a/libs/bimap/test/test_bimap.hpp
+++ b/libs/bimap/test/test_bimap.hpp
@@ -307,6 +307,7 @@ template< class Container, class Data >
 void test_simple_unordered_associative_container(Container & c, const Data & d)
 {
     c.clear();
+    c.reserve( std::distance(d.begin(), d.end()) );
     c.insert( d.begin(), d.end() );
 
     BOOST_CHECK( c.bucket_count() * c.max_load_factor() >= d.size() );
@@ -326,9 +327,13 @@ void test_simple_unordered_associative_container(Container & c, const Data & d)
         {
             const Container & const_c = c;
 
+            // Hash collisions should have no effect on the correctness of an
+            // unordered simple associative container. -- Cromwell D. Enage
+/*
             BOOST_CHECK(
                 const_c.bucket_size(const_c.bucket(*di)) == 1
             );
+*/
 
             typename Container::size_type nb =
                 const_c.bucket(*const_c.find(*di));
@@ -394,6 +399,7 @@ template< class Container, class Data >
 void test_pair_unordered_associative_container(Container & c, const Data & d)
 {
     c.clear();
+    c.reserve( std::distance(d.begin(), d.end()) );
     c.insert( d.begin(), d.end() );
 
     BOOST_CHECK( c.bucket_count() * c.max_load_factor() >= d.size() );
@@ -414,7 +420,13 @@ void test_pair_unordered_associative_container(Container & c, const Data & d)
         {
             const Container & const_c = c;
 
+            // The test commented out below fails on 32-bit Windows platforms
+            // but works on 64-bit Windows platforms and others.  Regardless,
+            // hash collisions should have no effect on the correctness of an
+            // unordered pair associative container. -- Cromwell D. Enage
+/*
             BOOST_CHECK( const_c.bucket_size(const_c.bucket(di->first)) == 1 );
+*/
 
             typename Container::size_type nb =
                 const_c.bucket(const_c.find(di->first)->first);
diff --git a/libs/bimap/test/test_bimap_unordered.cpp b/libs/bimap/test/test_bimap_unordered.cpp
index 6cba88b..8713642 100644
--- a/libs/bimap/test/test_bimap_unordered.cpp
+++ b/libs/bimap/test/test_bimap_unordered.cpp
@@ -79,6 +79,15 @@ void test_bimap()
         test_unordered_set_unordered_multiset_bimap(
             bm,data,left_data,right_data
         );
+
+        BOOST_CHECK((
+            bm.left.hash_function()(' ') == bm.left.hash_function()(' ')
+        ));
+        BOOST_CHECK((
+            bm.right.hash_function()(" ") == bm.right.hash_function()(" ")
+        ));
+        BOOST_CHECK((bm.left.key_eq()(' ', ' ')));
+        BOOST_CHECK((bm.right.key_eq()(" ", " ")));
     }
     //--------------------------------------------------------------------
 
@@ -103,6 +112,15 @@ void test_bimap()
             bm,data,left_data,right_data
         );
         test_tagged_bimap<left_tag,right_tag>(bm,data);
+
+        BOOST_CHECK((
+            bm.left.hash_function()(' ') == bm.left.hash_function()(' ')
+        ));
+        BOOST_CHECK((
+            bm.right.hash_function()(" ") == bm.right.hash_function()(" ")
+        ));
+        BOOST_CHECK((bm.left.key_eq()(' ', ' ')));
+        BOOST_CHECK((bm.right.key_eq()(" ", " ")));
     }
     //--------------------------------------------------------------------
 
@@ -128,6 +146,11 @@ void test_bimap()
         test_basic_bimap(bm,data,left_data,right_data);
         test_associative_container(bm,data);
         test_simple_unordered_associative_container(bm,data);
+
+        BOOST_CHECK((
+            bm.right.hash_function()(" ") == bm.right.hash_function()(" ")
+        ));
+        BOOST_CHECK((bm.right.key_eq()(" ", " ")));
     }
     //--------------------------------------------------------------------
 
@@ -154,6 +177,14 @@ void test_bimap()
         test_associative_container(bm,data);
         test_simple_unordered_associative_container(bm,data);
 
+        BOOST_CHECK((
+            bm.left.hash_function()(' ') == bm.left.hash_function()(' ')
+        ));
+        BOOST_CHECK((
+            bm.right.hash_function()(" ") == bm.right.hash_function()(" ")
+        ));
+        BOOST_CHECK((bm.left.key_eq()(' ', ' ')));
+        BOOST_CHECK((bm.right.key_eq()(" ", " ")));
     }
     //--------------------------------------------------------------------
 }
